# -*- coding: utf-8 -*-
"""Modelcode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15viLAsQz3XMdlYkU36sSFHEYDCewQsTx
"""

import tensorflow as tf
from tensorflow.keras.layers import Conv2D, BatchNormalization, MaxPooling2D, Dense, Flatten, Input
from tensorflow.keras.models import Model
import numpy as np
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import Input, Conv2D, BatchNormalization, MaxPooling2D, Flatten, Dense, Lambda ,UpSampling2D
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping

import numpy as np
import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, BatchNormalization, MaxPooling2D, UpSampling2D, Flatten, Dense, Lambda, Concatenate, GlobalAveragePooling2D
from tensorflow.keras.models import Model

# Define Denoising Expert Model
def create_denoising_expert():
    input_layer = Input(shape=(224,224,3))  # Input noisy image

    # Encoding path (Feature Extraction)
    x = Conv2D(16, (3, 3), activation='relu', padding='same')(input_layer)
    x = BatchNormalization()(x)
    x = MaxPooling2D((2, 2), padding='same')(x)  # Down-sampling
    x = Conv2D(32, (3, 3), activation='relu', padding='same')(x)
    x = BatchNormalization()(x)
    x = MaxPooling2D((2, 2), padding='same')(x)  # Down-sampling

    # Decoding path (Reconstruction)
    x = Conv2D(32, (3, 3), activation='relu', padding='same')(x)
    x = UpSampling2D((2, 2))(x)  # Up-sampling
    x = Conv2D(16, (3, 3), activation='relu', padding='same')(x)
    x = UpSampling2D((2, 2))(x)  # Up-sampling

    # Output layer - Reconstructed (denoised) image
    x = Conv2D(32, (3, 3), activation='relu', padding='same')(x)  # Keep spatial dimensions the same

    # Flatten the feature maps to pass to the gating network
    x = GlobalAveragePooling2D()(x)

    # Build model
    model = Model(inputs=input_layer, outputs=x)
    return model

# Define Fuzzy Logic Expert Model
def fuzzy_membership(x, a, b, c):
    return tf.maximum(0.0, tf.minimum((x - a) / (b - a), (c - x) / (c - b)))

def fuzzify_layer(input_layer):
    fuzzified = Lambda(lambda x: fuzzy_membership(x, 0.2, 0.5, 0.8))(input_layer)
    return fuzzified

def create_fuzzy_logic_expert():
    input_layer = Input(shape=(224,224,3))

    # Fuzzification of the input data
    fuzzified_input = fuzzify_layer(input_layer)

    # Regular CNN layers
    x = Conv2D(32, (5, 5), activation='relu', padding='same')(fuzzified_input)
    x = BatchNormalization()(x)
    x = Conv2D(64, (5, 5), activation='relu', padding='same')(x)
    x = MaxPooling2D((2, 2))(x)
    x = Conv2D(128, (3, 3), activation='relu', padding='same')(x)


    # Flatten and output layers
    x = GlobalAveragePooling2D()(x)
   # x = Dense(4, activation='softmax')(x)

    # Build model
    model = Model(inputs=input_layer, outputs=x)
    return model

# Define Adversarially Trained Expert Model
def create_adversarially_trained_expert():
    input_layer = Input(shape=(224,224,3))
    x = Conv2D(64, (3, 3), activation='relu', padding='same')(input_layer)
    x = BatchNormalization()(x)
    x = Conv2D(128, (3, 3), activation='relu', padding='same')(x)
    x = MaxPooling2D((2, 2))(x)
    x = Conv2D(256, (3, 3), activation='relu', padding='same')(x)

    x = GlobalAveragePooling2D()(x)
  #  x = Dense(4, activation='softmax')(x)
    model = Model(inputs=input_layer, outputs=x)
    return model

# Define Gating Network Model
def create_gating_network(input_shape):
    input_layer = Input(shape=input_shape)
    x = Dense(512, activation='relu')(input_layer)
    x = Dense(4, activation='softmax')(x)
    model = Model(inputs=input_layer, outputs=x)
    return model

def create_model(input_shape, learning_rate=0.001, batch_size=32, num_layers=3):
    # Create each model
    denoising_expert = create_denoising_expert()
    fuzzy_logic_expert = create_fuzzy_logic_expert()
    adversarially_trained_expert = create_adversarially_trained_expert()

    # Define input layer
    input_layer = Input(shape=input_shape)

    # Get features from the denoising expert
    denoised_features = denoising_expert(input_layer)

    # Extract features from each expert
    fuzzy_features = fuzzy_logic_expert(input_layer)
    adversarial_features = adversarially_trained_expert(input_layer)

    # Concatenate features from all experts
    combined_features = Concatenate()([fuzzy_features, adversarial_features, denoised_features])

    # Define the gating network
    gating_network = create_gating_network(combined_features.shape[1:])

    # Final prediction
    final_output = gating_network(combined_features)

    # Create and compile the combined model with the learning_rate parameter
    model = Model(inputs=input_layer, outputs=final_output)
    model.compile(optimizer=Adam(learning_rate=learning_rate),
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])

    return model


# Define input shape
input_shape = (224,224, 3)

# Create the combined model
model = create_model(input_shape)

# Summary of the combined model
model.summary()