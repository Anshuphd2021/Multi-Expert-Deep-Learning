# -*- coding: utf-8 -*-
"""FUZZYFIED DIFRENT LAYER.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MfSc05hq9qdpE7b4GgvaTjEFvplVklD4
"""

from google.colab import drive
drive.mount('/content/drive')

import tensorflow as tf
from tensorflow.keras.layers import Conv2D, BatchNormalization, MaxPooling2D, Dense, Flatten, Input
from tensorflow.keras.models import Model
import numpy as np
from tensorflow.keras.preprocessing.image import ImageDataGenerator

datagen = datagen = ImageDataGenerator(rescale=1./255)


training_set = datagen.flow_from_directory(
      '/content/drive/MyDrive/Colab Notebooks/BT/Training',
        target_size=(112,112),
        batch_size=32,
        shuffle= True,
        class_mode='categorical')

val_set = datagen.flow_from_directory(
        '/content/drive/MyDrive/Colab Notebooks/BT/Testing',
        target_size=(112,112),
        batch_size=16,
        shuffle= False,
        class_mode="categorical")

test_set = datagen.flow_from_directory(
        '/content/drive/MyDrive/Colab Notebooks/BT/Testing',
        target_size=(112,112),
        batch_size=32,
        shuffle= False,
        class_mode="categorical")

import numpy as np
import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, BatchNormalization, MaxPooling2D, Flatten, Dense, Lambda ,UpSampling2D
from tensorflow.keras.models import Model

import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, BatchNormalization, MaxPooling2D, GlobalAveragePooling2D, Lambda, Dense
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import numpy as np
import time

# Define multiple fuzzy membership functions for different ranges
def fuzzy_membership(x, a, b, c):
    return tf.maximum(0.0, tf.minimum((x - a) / (b - a), (c - x) / (c - b)))

# Fuzzification layer for multiple ranges
def fuzzify_layer(input_layer):
    fuzzified_01 = Lambda(lambda x: fuzzy_membership(x, 0.0, 0.2, 0.4))(input_layer)
    fuzzified_14 = Lambda(lambda x: fuzzy_membership(x, 0.4, 0.5, 0.7))(input_layer)
    fuzzified_48 = Lambda(lambda x: fuzzy_membership(x, 0.7, 0.8, 1.0))(input_layer)

    return fuzzified_01, fuzzified_14, fuzzified_48

# Define Fuzzy Logic Expert Model
def create_fuzzy_logic_expert():
    input_layer = Input(shape=(112, 112, 3))

    # Fuzzification with multiple ranges
    fuzzified_01, fuzzified_14, fuzzified_48 = fuzzify_layer(input_layer)

    # Convolutional layers after fuzzification for each fuzzy range
    x_01 = Conv2D(32, (5, 5), activation='relu', padding='same')(fuzzified_01)
    x_01 = BatchNormalization()(x_01)
    x_01 = Conv2D(64, (5, 5), activation='relu', padding='same')(x_01)
    x_01 = MaxPooling2D((2, 2))(x_01)
    x_01 = Conv2D(128, (3, 3), activation='relu', padding='same')(x_01)
    x_01 = GlobalAveragePooling2D()(x_01)

    x_14 = Conv2D(32, (5, 5), activation='relu', padding='same')(fuzzified_14)
    x_14 = BatchNormalization()(x_14)
    x_14 = Conv2D(64, (5, 5), activation='relu', padding='same')(x_14)
    x_14 = MaxPooling2D((2, 2))(x_14)
    x_14 = Conv2D(128, (3, 3), activation='relu', padding='same')(x_14)
    x_14 = GlobalAveragePooling2D()(x_14)

    x_48 = Conv2D(32, (5, 5), activation='relu', padding='same')(fuzzified_48)
    x_48 = BatchNormalization()(x_48)
    x_48 = Conv2D(64, (5, 5), activation='relu', padding='same')(x_48)
    x_48 = MaxPooling2D((2, 2))(x_48)
    x_48 = Conv2D(128, (3, 3), activation='relu', padding='same')(x_48)
    x_48 = GlobalAveragePooling2D()(x_48)

    # Return all three outputs (features from different fuzzy ranges)
    return Model(inputs=input_layer, outputs=[x_01, x_14, x_48])

# Define Gating Network
def create_gating_network(input_shape, num_classes):
    input_layer = Input(shape=input_shape)
    x = Dense(128, activation='relu')(input_layer)
    x = Dense(num_classes, activation='softmax')(x)
    return Model(inputs=input_layer, outputs=x)

# Define Combined Model with Gating Network
def create_combined_model_with_gating(num_classes):
    input_layer = Input(shape=(112, 112, 3))
    fuzzy_logic_expert = create_fuzzy_logic_expert()

    # Extract features from fuzzy logic expert (one output for each fuzzy range)
    fuzzy_features_01, fuzzy_features_14, fuzzy_features_48 = fuzzy_logic_expert(input_layer)

    # Gating network with num_classes passed as an argument
    gating_network_01 = create_gating_network(fuzzy_features_01.shape[1:], num_classes)
    gating_network_14 = create_gating_network(fuzzy_features_14.shape[1:], num_classes)
    gating_network_48 = create_gating_network(fuzzy_features_48.shape[1:], num_classes)

    # Apply gating networks to each set of fuzzy features
    final_output_01 = gating_network_01(fuzzy_features_01)
    final_output_14 = gating_network_14(fuzzy_features_14)
    final_output_48 = gating_network_48(fuzzy_features_48)

    # Combined model with multiple outputs for different fuzzy ranges
    model = Model(inputs=input_layer, outputs=[final_output_01, final_output_14, final_output_48])
    return model

# Function to evaluate the model and compute accuracy, precision, recall, and F1 score
def evaluate_model_with_metrics(model, val_set):
    # Get true labels from the validation set
    true_labels = val_set.classes
    true_labels = tf.keras.utils.to_categorical(true_labels, num_classes=len(val_set.class_indices))

    # Get predictions from the model (one for each fuzzy range)
    preds_01, preds_14, preds_48 = model.predict(val_set, batch_size=32)

    # Convert probabilities to class predictions
    preds_01 = np.argmax(preds_01, axis=1)
    preds_14 = np.argmax(preds_14, axis=1)
    preds_48 = np.argmax(preds_48, axis=1)

    true_labels = np.argmax(true_labels, axis=1)  # Convert one-hot to class indices

    # Evaluate metrics for each output
    for i, (preds, range_label) in enumerate(zip([preds_01, preds_14, preds_48], ['0-1', '1-4', '4-8'])):
        accuracy = accuracy_score(true_labels, preds)
        precision = precision_score(true_labels, preds, average='weighted')
        recall = recall_score(true_labels, preds, average='weighted')
        f1 = f1_score(true_labels, preds, average='weighted')

        # Print metrics for this range
        print(f"Metrics for fuzzy range {range_label}:")
        print(f"  Accuracy: {accuracy:.4f}")
        print(f"  Precision: {precision:.4f}")
        print(f"  Recall: {recall:.4f}")
        print(f"  F1 Score: {f1:.4f}")


def run_experiment_with_model(learning_rate, batch_size, epochs=50, num_classes=4):
    # Prepare data generators
    datagen = ImageDataGenerator(rescale=1./255)

    training_set = datagen.flow_from_directory(
        '/content/drive/MyDrive/Colab Notebooks/BT/Training',
        target_size=(112, 112),
        batch_size=batch_size,
        shuffle=True,
        class_mode='categorical'
    )

    val_set = datagen.flow_from_directory(
        '/content/drive/MyDrive/Colab Notebooks/BT/Testing',
        target_size=(112, 112),
        batch_size=batch_size,
        shuffle=False,
        class_mode="categorical"
    )

    # Create the combined model with gating
    combined_model = create_combined_model_with_gating(num_classes)

    # Compile the model
    combined_model.compile(
        optimizer=Adam(learning_rate=learning_rate),
        loss=['categorical_crossentropy'] * 3,  # Loss for each output
        metrics=[['accuracy']] * 3  # Metrics for each output
    )

    # Time the model training
    t0 = time.time()
    combined_model.fit(training_set, epochs=epochs, validation_data=val_set, batch_size=batch_size)
    t1 = time.time()

    # Evaluate the model
    evaluate_model_with_metrics(combined_model, val_set)

    return None, t1 - t0

# Set learning rate and batch size
learning_rate = 0.001
batch_size = 32
epochs = 50
num_classes = 4  # Replace with the actual number of classes

# Run the experiment
accuracy, training_time = run_experiment_with_model(learning_rate, batch_size, epochs, num_classes)

# Display results
print(f"Training Time: {training_time:.2f} seconds")









import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, BatchNormalization, MaxPooling2D, GlobalAveragePooling2D, Lambda, Dense
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import numpy as np
import time

# Define multiple fuzzy membership functions for different ranges
def fuzzy_membership(x, a, b, c):
    return tf.maximum(0.0, tf.minimum((x - a) / (b - a), (c - x) / (c - b)))

# Fuzzification layer for multiple ranges
def fuzzify_layer(input_layer):
    fuzzified_01 = Lambda(lambda x: fuzzy_membership(x, 0.0, 0.2, 0.4))(input_layer)
    fuzzified_14 = Lambda(lambda x: fuzzy_membership(x, 0.4, 0.5, 0.6))(input_layer)
    fuzzified_48 = Lambda(lambda x: fuzzy_membership(x, 0.6, 0.8, 1.0))(input_layer)

    return fuzzified_01, fuzzified_14, fuzzified_48

# Define Fuzzy Logic Expert Model
def create_fuzzy_logic_expert():
    input_layer = Input(shape=(112, 112, 3))

    # Fuzzification with multiple ranges
    fuzzified_01, fuzzified_14, fuzzified_48 = fuzzify_layer(input_layer)

    # Convolutional layers after fuzzification for each fuzzy range
    x_01 = Conv2D(32, (5, 5), activation='relu', padding='same')(fuzzified_01)
    x_01 = BatchNormalization()(x_01)
    x_01 = Conv2D(64, (5, 5), activation='relu', padding='same')(x_01)
    x_01 = MaxPooling2D((2, 2))(x_01)
    x_01 = Conv2D(128, (3, 3), activation='relu', padding='same')(x_01)
    x_01 = GlobalAveragePooling2D()(x_01)

    x_14 = Conv2D(32, (5, 5), activation='relu', padding='same')(fuzzified_14)
    x_14 = BatchNormalization()(x_14)
    x_14 = Conv2D(64, (5, 5), activation='relu', padding='same')(x_14)
    x_14 = MaxPooling2D((2, 2))(x_14)
    x_14 = Conv2D(128, (3, 3), activation='relu', padding='same')(x_14)
    x_14 = GlobalAveragePooling2D()(x_14)

    x_48 = Conv2D(32, (5, 5), activation='relu', padding='same')(fuzzified_48)
    x_48 = BatchNormalization()(x_48)
    x_48 = Conv2D(64, (5, 5), activation='relu', padding='same')(x_48)
    x_48 = MaxPooling2D((2, 2))(x_48)
    x_48 = Conv2D(128, (3, 3), activation='relu', padding='same')(x_48)
    x_48 = GlobalAveragePooling2D()(x_48)

    # Return all three outputs (features from different fuzzy ranges)
    return Model(inputs=input_layer, outputs=[x_01, x_14, x_48])

# Define Gating Network
def create_gating_network(input_shape, num_classes):
    input_layer = Input(shape=input_shape)
    x = Dense(128, activation='relu')(input_layer)
    x = Dense(num_classes, activation='softmax')(x)
    return Model(inputs=input_layer, outputs=x)

# Define Combined Model with Gating Network
def create_combined_model_with_gating(num_classes):
    input_layer = Input(shape=(112, 112, 3))
    fuzzy_logic_expert = create_fuzzy_logic_expert()

    # Extract features from fuzzy logic expert (one output for each fuzzy range)
    fuzzy_features_01, fuzzy_features_14, fuzzy_features_48 = fuzzy_logic_expert(input_layer)

    # Gating network with num_classes passed as an argument
    gating_network_01 = create_gating_network(fuzzy_features_01.shape[1:], num_classes)
    gating_network_14 = create_gating_network(fuzzy_features_14.shape[1:], num_classes)
    gating_network_48 = create_gating_network(fuzzy_features_48.shape[1:], num_classes)

    # Apply gating networks to each set of fuzzy features
    final_output_01 = gating_network_01(fuzzy_features_01)
    final_output_14 = gating_network_14(fuzzy_features_14)
    final_output_48 = gating_network_48(fuzzy_features_48)

    # Combined model with multiple outputs for different fuzzy ranges
    model = Model(inputs=input_layer, outputs=[final_output_01, final_output_14, final_output_48])
    return model

# Function to evaluate the model and compute accuracy, precision, recall, and F1 score
def evaluate_model_with_metrics(model, val_set):
    # Get true labels from the validation set
    true_labels = val_set.classes
    true_labels = tf.keras.utils.to_categorical(true_labels, num_classes=len(val_set.class_indices))

    # Get predictions from the model (one for each fuzzy range)
    preds_01, preds_14, preds_48 = model.predict(val_set, batch_size=32)

    # Convert probabilities to class predictions
    preds_01 = np.argmax(preds_01, axis=1)
    preds_14 = np.argmax(preds_14, axis=1)
    preds_48 = np.argmax(preds_48, axis=1)

    true_labels = np.argmax(true_labels, axis=1)  # Convert one-hot to class indices

    # Evaluate metrics for each output
    for i, (preds, range_label) in enumerate(zip([preds_01, preds_14, preds_48], ['0.0 - 0.4', '0.4 - 0.7', '0.7 - 1.0'])):
        accuracy = accuracy_score(true_labels, preds)
        precision = precision_score(true_labels, preds, average='weighted')
        recall = recall_score(true_labels, preds, average='weighted')
        f1 = f1_score(true_labels, preds, average='weighted')

        # Print metrics for this range
        print(f"Metrics for fuzzy range {range_label}:")
        print(f"  Accuracy: {accuracy:.4f}")
        print(f"  Precision: {precision:.4f}")
        print(f"  Recall: {recall:.4f}")
        print(f"  F1 Score: {f1:.4f}")


def run_experiment_with_model(learning_rate, batch_size, epochs=50, num_classes=4):
    # Prepare data generators
    datagen = ImageDataGenerator(rescale=1./255)

    training_set = datagen.flow_from_directory(
        '/content/drive/MyDrive/Colab Notebooks/BT/Training',
        target_size=(112, 112),
        batch_size=batch_size,
        shuffle=True,
        class_mode='categorical'
    )

    val_set = datagen.flow_from_directory(
        '/content/drive/MyDrive/Colab Notebooks/BT/Testing',
        target_size=(112, 112),
        batch_size=batch_size,
        shuffle=False,
        class_mode="categorical"
    )

    # Create the combined model with gating
    combined_model = create_combined_model_with_gating(num_classes)

    # Compile the model
    combined_model.compile(
        optimizer=Adam(learning_rate=learning_rate),
        loss=['categorical_crossentropy'] * 3,  # Loss for each output
        metrics=[['accuracy']] * 3  # Metrics for each output
    )

    # Time the model training
    t0 = time.time()
    combined_model.fit(training_set, epochs=epochs, validation_data=val_set, batch_size=batch_size)
    t1 = time.time()

    # Evaluate the model
    evaluate_model_with_metrics(combined_model, val_set)

    return None, t1 - t0

# Set learning rate and batch size
learning_rate = 0.001
batch_size = 32
epochs = 50
num_classes = 4  # Replace with the actual number of classes

# Run the experiment
accuracy, training_time = run_experiment_with_model(learning_rate, batch_size, epochs, num_classes)

# Display results
print(f"Training Time: {training_time:.2f} seconds")





import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, BatchNormalization, MaxPooling2D, GlobalAveragePooling2D, Lambda, Dense
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
import numpy as np
import time

# Define multiple fuzzy membership functions for different ranges
def fuzzy_membership(x, a, b, c):
    return tf.maximum(0.0, tf.minimum((x - a) / (b - a), (c - x) / (c - b)))

# Fuzzification layer for multiple ranges
def fuzzify_layer(input_layer):
    fuzzified_01 = Lambda(lambda x: fuzzy_membership(x, 0.0, 0.2, 0.8))(input_layer)
    fuzzified_14 = Lambda(lambda x: fuzzy_membership(x, 1.0, 2.0, 4.0))(input_layer)
    fuzzified_48 = Lambda(lambda x: fuzzy_membership(x, 4.0, 6.0, 8.0))(input_layer)

    return fuzzified_01, fuzzified_14, fuzzified_48

# Define Fuzzy Logic Expert Model
def create_fuzzy_logic_expert():
    input_layer = Input(shape=(112, 112, 3))

    # Fuzzification with multiple ranges
    fuzzified_01, fuzzified_14, fuzzified_48 = fuzzify_layer(input_layer)

    # Convolutional layers after fuzzification for each fuzzy range
    x_01 = Conv2D(32, (5, 5), activation='relu', padding='same')(fuzzified_01)
    x_01 = BatchNormalization()(x_01)
    x_01 = Conv2D(64, (5, 5), activation='relu', padding='same')(x_01)
    x_01 = MaxPooling2D((2, 2))(x_01)
    x_01 = Conv2D(128, (3, 3), activation='relu', padding='same')(x_01)
    x_01 = GlobalAveragePooling2D()(x_01)

    x_14 = Conv2D(32, (5, 5), activation='relu', padding='same')(fuzzified_14)
    x_14 = BatchNormalization()(x_14)
    x_14 = Conv2D(64, (5, 5), activation='relu', padding='same')(x_14)
    x_14 = MaxPooling2D((2, 2))(x_14)
    x_14 = Conv2D(128, (3, 3), activation='relu', padding='same')(x_14)
    x_14 = GlobalAveragePooling2D()(x_14)

    x_48 = Conv2D(32, (5, 5), activation='relu', padding='same')(fuzzified_48)
    x_48 = BatchNormalization()(x_48)
    x_48 = Conv2D(64, (5, 5), activation='relu', padding='same')(x_48)
    x_48 = MaxPooling2D((2, 2))(x_48)
    x_48 = Conv2D(128, (3, 3), activation='relu', padding='same')(x_48)
    x_48 = GlobalAveragePooling2D()(x_48)

    # Return all three outputs (features from different fuzzy ranges)
    return Model(inputs=input_layer, outputs=[x_01, x_14, x_48])

# Define Gating Network
def create_gating_network(input_shape, num_classes):
    input_layer = Input(shape=input_shape)
    x = Dense(128, activation='relu')(input_layer)
    x = Dense(num_classes, activation='softmax')(x)
    return Model(inputs=input_layer, outputs=x)

# Define Combined Model with Gating Network
def create_combined_model_with_gating(num_classes):
    input_layer = Input(shape=(112, 112, 3))
    fuzzy_logic_expert = create_fuzzy_logic_expert()

    # Extract features from fuzzy logic expert (one output for each fuzzy range)
    fuzzy_features_01, fuzzy_features_14, fuzzy_features_48 = fuzzy_logic_expert(input_layer)

    # Gating network with num_classes passed as an argument
    gating_network_01 = create_gating_network(fuzzy_features_01.shape[1:], num_classes)
    gating_network_14 = create_gating_network(fuzzy_features_14.shape[1:], num_classes)
    gating_network_48 = create_gating_network(fuzzy_features_48.shape[1:], num_classes)

    # Apply gating networks to each set of fuzzy features
    final_output_01 = gating_network_01(fuzzy_features_01)
    final_output_14 = gating_network_14(fuzzy_features_14)
    final_output_48 = gating_network_48(fuzzy_features_48)

    # Combined model with multiple outputs for different fuzzy ranges
    model = Model(inputs=input_layer, outputs=[final_output_01, final_output_14, final_output_48])
    return model

# Function to evaluate the model and compute accuracy, precision, recall, and F1 score
def evaluate_model_with_metrics(model, val_set):
    # Get true labels from the validation set
    true_labels = val_set.classes
    true_labels = tf.keras.utils.to_categorical(true_labels, num_classes=len(val_set.class_indices))

    # Get predictions from the model (one for each fuzzy range)
    preds_01, preds_14, preds_48 = model.predict(val_set, batch_size=32)

    # Convert probabilities to class predictions
    preds_01 = np.argmax(preds_01, axis=1)
    preds_14 = np.argmax(preds_14, axis=1)
    preds_48 = np.argmax(preds_48, axis=1)

    true_labels = np.argmax(true_labels, axis=1)  # Convert one-hot to class indices

    # Evaluate metrics for each output
    for i, (preds, range_label) in enumerate(zip([preds_01, preds_14, preds_48], ['0.0 - 0.8', '1.0 - 4.0', '4.0 - 8.0'])):
        accuracy = accuracy_score(true_labels, preds)
        precision = precision_score(true_labels, preds, average='weighted')
        recall = recall_score(true_labels, preds, average='weighted')
        f1 = f1_score(true_labels, preds, average='weighted')

        # Print metrics for this range
        print(f"Metrics for fuzzy range {range_label}:")
        print(f"  Accuracy: {accuracy:.4f}")
        print(f"  Precision: {precision:.4f}")
        print(f"  Recall: {recall:.4f}")
        print(f"  F1 Score: {f1:.4f}")


def run_experiment_with_model(learning_rate, batch_size, epochs=50, num_classes=4):
    # Prepare data generators
    datagen = ImageDataGenerator(rescale=1./255)

    training_set = datagen.flow_from_directory(
        '/content/drive/MyDrive/Colab Notebooks/BT/Training',
        target_size=(112, 112),
        batch_size=batch_size,
        shuffle=True,
        class_mode='categorical'
    )

    val_set = datagen.flow_from_directory(
        '/content/drive/MyDrive/Colab Notebooks/BT/Testing',
        target_size=(112, 112),
        batch_size=batch_size,
        shuffle=False,
        class_mode="categorical"
    )

    # Create the combined model with gating
    combined_model = create_combined_model_with_gating(num_classes)

    # Compile the model
    combined_model.compile(
        optimizer=Adam(learning_rate=learning_rate),
        loss=['categorical_crossentropy'] * 3,  # Loss for each output
        metrics=[['accuracy']] * 3  # Metrics for each output
    )

    # Time the model training
    t0 = time.time()
    combined_model.fit(training_set, epochs=epochs, validation_data=val_set, batch_size=batch_size)
    t1 = time.time()

    # Evaluate the model
    evaluate_model_with_metrics(combined_model, val_set)

    return None, t1 - t0

# Set learning rate and batch size
learning_rate = 0.001
batch_size = 32
epochs = 50
num_classes = 4  # Replace with the actual number of classes

# Run the experiment
accuracy, training_time = run_experiment_with_model(learning_rate, batch_size, epochs, num_classes)

# Display results
print(f"Training Time: {training_time:.2f} seconds")